#include "priority_queue.h"

// Initialize a new priority queue
PriorityQueue* pq_init() {
    PriorityQueue *pq = malloc(sizeof(PriorityQueue));
    if (!pq) {
        perror("Memory allocation failed for priority queue");
        exit(EXIT_FAILURE);
    }
    pq->head = NULL;
    pq->size = 0;
    return pq;
}

// Check if the priority queue is empty
int pq_is_empty(PriorityQueue *pq) {
    return pq->head == NULL;
}

// Enqueue a node with a given priority
void pq_enqueue(PriorityQueue *pq, int x, int y, int distance) {
    PQNode *new_node = malloc(sizeof(PQNode));
    if (!new_node) {
        perror("Memory allocation failed for priority queue node");
        exit(EXIT_FAILURE);
    }
    
    new_node->x = x;
    new_node->y = y;
    new_node->distance = distance;
    new_node->next = NULL;
    
    // If queue is empty or new node has higher priority (lower distance)
    if (pq->head == NULL || distance < pq->head->distance) {
        new_node->next = pq->head;
        pq->head = new_node;
    } else {
        PQNode *current = pq->head;
        
        // Find the position to insert
        while (current->next != NULL && current->next->distance <= distance) {
            current = current->next;
        }
        
        new_node->next = current->next;
        current->next = new_node;
    }
    
    pq->size++;
}

// Dequeue the highest priority element (lowest distance)
PQNode* pq_dequeue(PriorityQueue *pq) {
    if (pq_is_empty(pq)) {
        return NULL;
    }
    
    PQNode *node = pq->head;
    pq->head = pq->head->next;
    pq->size--;
    
    return node;
}

// Update the priority (distance) of a node if the new distance is smaller
void pq_decrease_key(PriorityQueue *pq, int x, int y, int new_distance) {
    // First check if the node exists in the queue
    PQNode *current = pq->head;
    PQNode *prev = NULL;
    
    while (current != NULL) {
        if (current->x == x && current->y == y) {
            // Found the node
            if (new_distance < current->distance) {
                // Remove from current position
                if (prev == NULL) {
                    pq->head = current->next;
                } else {
                    prev->next = current->next;
                }
                pq->size--;
                
                // Re-insert with new priority
                free(current);
                pq_enqueue(pq, x, y, new_distance);
            }
            return;
        }
        prev = current;
        current = current->next;
    }
    
    // Node not found, so add it
    pq_enqueue(pq, x, y, new_distance);
}

// Check if a node exists in the queue
int pq_contains(PriorityQueue *pq, int x, int y) {
    PQNode *current = pq->head;
    
    while (current != NULL) {
        if (current->x == x && current->y == y) {
            return 1;
        }
        current = current->next;
    }
    
    return 0;
}

// Free the priority queue
void pq_free(PriorityQueue *pq) {
    PQNode *current = pq->head;
    PQNode *next;
    
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    
    free(pq);
}